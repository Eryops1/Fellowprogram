model_fin <- gbm.all
# Chunk 1: setup
# Argument invalidin github_markdown: fig_caption: yes
# warnings on/off
oldw <- getOption("warn")
options(warn = -1)
knitr::opts_chunk$set(echo = TRUE, warnings=FALSE)
library(ggplot2)
library(readxl)
library(gridExtra)
library(grid)
library(scales)
library(gsubfn)
library(effects)
library(readr)
library(knitcitations)
# Chunk 2: data_exploration
dat <- read.csv("model_data2.csv")
# Create a second dataframe with complete cases only
names(dat)
plot(dat[,c("ma_range", "mni_max", "spec_max", "lat_range", "gcd", "grid_cells", "asl_pred",
"mean_lat", "min_lat", "habitat_width", "noo")])
# Chunk 3: duration_vs_habitat_width
boxplot(ma_range~habitat_width, dat)
tapply(dat$ma_range, factor(dat$habitat_width), psych::describe)
pairwise.wilcox.test(dat$ma_range, factor(dat$habitat_width), p.adjust.method = "fdr")
table(dat$habitat_width)
# Without single-interval species
dat_ns <- dat[dat$ma_range>0,]
dat_ns <- droplevels(dat_ns)
boxplot(ma_range~habitat_width, dat_ns)
tapply(dat_ns$ma_range, factor(dat_ns$habitat_width), psych::describe)
kruskal.test(dat_ns$ma_range, factor(dat_ns$habitat_width))
pairwise.wilcox.test(dat_ns$ma_range, factor(dat_ns$habitat_width), p.adjust.method = "fdr")
table(dat_ns$habitat_width)
# Number of occurrences correlates with habitat width?
cor.test(dat$noo, dat$habitat_width, method="spearman")
boxplot(noo~habitat_width, dat)
kruskal.test(noo~habitat_width, dat)
pairwise.wilcox.test(dat$noo, dat$habitat_width, p.adjust.method = "fdr")
# Chunk 4: bodysize_vs_duration
cor.test(dat$ma_range, dat$asl_pred)
plot(dat$ma_range, dat$asl_pred)
# Chunk 5: bodysize_vs_habitat
boxplot(asl_pred~habitat_width, dat)
kruskal.test(asl_pred~habitat_width, dat)
boxplot(asl_pred~grid_cells, dat, varwidth=TRUE)
kruskal.test(asl_pred~grid_cells, dat)
kruskal.test(asl_pred~grid_cells, dat_ns)
# Chunk 6: going_north
hist(dat$mean_lat, breaks=20)
table(dat$mean_lat>0)/nrow(dat)
# Chunk 7: going_north2
boxplot(mean_lat~habitat_width, dat)
cor.test(dat$mean_lat, dat$habitat_width, method="spearman")
kruskal.test(dat$mean_lat, dat$habitat_width)
pairwise.wilcox.test(dat$mean_lat, dat$habitat_width, p.adjust.method = "fdr")
boxplot(mean_lat~grid_cells, dat, varwidth=TRUE)
cor.test(dat$mean_lat, dat$grid_cells, method="spearman")
kruskal.test(mean_lat~grid_cells, dat)
kruskal.test(mean_lat~grid_cells, dat_ns)
# Chunk 8: going_north_sample_size_influence_habitat
cor.test(dat$habitat_width, dat$hab_w_boot)
plot(dat$habitat_width~dat$hab_w_boot)
cor.test(dat$mean_lat, dat$hab_w_boot, method="spearman")
kruskal.test(dat$mean_lat, dat$hab_w_boot)
summary(lm(dat$mean_lat~dat$hab_w_boot))
# Chunk 9: going_north_sample_size_influence_habitat2
stat <- c()
p.stat <- c()
south <- dat[dat$mean_lat<0,]
north <- dat[dat$mean_lat>=0,]
for(i in 1:1000){
temp.n <- north[sample(c(1:nrow(north)), nrow(south)),]
temp <- rbind(temp.n, south)
res <- cor.test(temp$mean_lat, temp$hab_w_boot, method="spearman")
stat <- c(stat, res$estimate[[1]])
p.stat <- c(p.stat, res$p.value[[1]])
i <- i+1
}
hist(stat, breaks=20, xlab="rho", main="distribution or rho from bootstrap")
abline(v=cor.test(dat$mean_lat, dat$hab_w_boot, method="spearman")$estimate[[1]], col="red")
text(x=cor.test(dat$mean_lat, dat$hab_w_boot, method="spearman")$estimate[[1]], y=80,"rho complete data")
shapiro.test(stat)
abline(v=psych::describe(stat)$mean+2*sd(stat), lty=2, col="grey")
abline(v=psych::describe(stat)$median-2*sd(stat), lty=2, col="grey")
psych::describe(stat)
hist(p.stat, breaks=20, main="distribution of p values from bootstrap")
abline(v=0.05, col="red")
text(x=0.05,y=60, "alpha=0.05")
table(p.stat>=0.05)/length(p.stat)
# Chunk 10: going_north_sample_size_influence_grid_cells
stat_grid <- c()
p.stat_grid <- c()
south <- dat[dat$mean_lat<0,]
north <- dat[dat$mean_lat>=0,]
for(i in 1:1000){
temp.n <- north[sample(c(1:nrow(north)), nrow(south)),]
temp <- rbind(temp.n, south)
res <- cor.test(temp$mean_lat, temp$grid_cells, method="spearman")
stat_grid <- c(stat_grid, res$estimate[[1]])
p.stat_grid <- c(p.stat_grid, res$p.value[[1]])
i <- i+1
}
hist(stat_grid, breaks=20)
abline(v=cor.test(dat$mean_lat, dat$grid_cells, method="spearman")$estimate[[1]], col="red")
shapiro.test(stat_grid)
abline(v=psych::describe(stat_grid)$median+2*psych::describe(stat_grid)$mad, lty=2, col="grey")
abline(v=psych::describe(stat_grid)$median-2*psych::describe(stat_grid)$mad, lty=2, col="grey")
psych::describe(stat_grid)
hist(log(p.stat_grid), breaks=20, main="distribution rho bootstrap")
abline(v=log(0.05), col="red")
table(p.stat_grid>=0.05)/length(p.stat_grid)
# Chunk 11: geo_range_southern_hemisphere
cor.test(abs(south$mean_lat), south$grid_cells, method="spearman")
cor.test(abs(north$mean_lat), north$grid_cells, method="spearman")
# Chunk 12: zuur_data_exploration
lm3 <- lm(data=dat, ma_range ~ mni_max + spec_max + grid_cells + gcd + lat_range +
mean_lat + min_lat + asl_pred + hab.cat.b + habitat_width + hab_w_boot + noo)
op <- par(mfrow=c(4,4), mar=c(5,4,1,2))
plot(lm3, add.smooth = FALSE, which=1)
hist(resid(lm3), xlab="Residuals", main="", breaks=20)
plot(dat$mni_max[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$spec_max[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$grid_cells[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$gcd[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$lat_range[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$mean_lat[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$min_lat[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$asl_pred[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$hab.cat.b[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$habitat_width[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$hab_w_boot[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
plot(dat$noo[as.numeric(names(resid(lm3)))], resid(lm3), ylab="Residuals")
par(op)
# Chunk 13
correlation <- cor(dat[,c("mni_max", "spec_max", "grid_cells", "gcd", "lat_range", "mean_lat",
"min_lat", "asl_pred", "habitat_width", "hab_w_boot", "noo")],
use="complete.obs", method="spearman")
correlation
# Chunk 14
E <- resid(lm3)
var.test(E[dat$habitat_width<2], E[dat$habitat_width>=2])
bartlett.test(E, dat$hab.cat.b[as.numeric(names(resid(lm3)))])
# Chunk 15
op <- par(mfrow=c(2,2), mar=c(5,4,1,2))
plot(lm3)
par(op)
# Chunk 16: check linear first
lm1 <- lm(data=dat, ma_range ~ mni_max + grid_cells + mean_lat + asl_pred + hab.cat.b + hab_w_boot)
op <- par(mfrow = c(3, 3), mar = c(4, 4, 2, 2))
plot(lm1, which = c(1), col = 1, add.smooth = FALSE, caption = "")
plot(dat$mni_max[as.numeric(names(lm1$residuals))], resid(lm1), xlab = "MNI", ylab = "Residuals")
plot(dat$grid_cells[as.numeric(names(lm1$residuals))], resid(lm1), xlab = "Grid cells", ylab = "Residuals")
plot(dat$mean_lat[as.numeric(names(lm1$residuals))], resid(lm1), xlab = "Mean latitude", ylab = "Residuals")
plot(dat$asl_pred[as.numeric(names(lm1$residuals))], resid(lm1), xlab = "Bodysize", ylab = "Residuals")
plot(dat$hab.cat.b[as.numeric(names(lm1$residuals))], resid(lm1), xlab = "Habitat type", ylab = "Residuals")
plot(dat$hab_w_boot[as.numeric(names(lm1$residuals))], resid(lm1), xlab = "Habitat width", ylab = "Residuals")
par(op)
# Chunk 17
# gls cannot handle missing values therefor I have to create a subdataset with complete observations only
dat.m <- na.omit(dat[,c("ma_range", "mni_max", "grid_cells", "mean_lat", "asl_pred",
"hab.cat.b", "hab_w_boot", "order")])
library(nlme)
Form <- formula(ma_range ~ mni_max + grid_cells + mean_lat + asl_pred +
hab.cat.b + hab_w_boot)
gls1 <- gls(data=dat.m, Form)
vf1Comb <- varComb(varExp(form= ~ asl_pred),
varExp(form= ~ grid_cells),
varPower(form= ~ mean_lat),
varConstPower(form= ~ mni_max),
varPower(form= ~ hab_w_boot))
# the best combination of adjusting for varying variances
gls2 <- gls(data=dat.m, Form, weights = vf1Comb, method="REML")
anova(gls1, gls2)
summary(gls2)
# Chunk 18
dev.new()
op <- par(mfrow = c(3, 3), mar = c(4, 4, 2, 2))
plot(gls2, which = c(1), col = 1, add.smooth = FALSE, caption = "")
plot(dat$mni_max[as.numeric(names(gls2$residuals))], resid(gls2), xlab = "MNI", ylab = "Residuals")
plot(dat$grid_cells[as.numeric(names(gls2$residuals))], resid(gls2), xlab = "Grid cells", ylab = "Residuals")
plot(dat$mean_lat[as.numeric(names(gls2$residuals))], resid(gls2), xlab = "Mean latitude", ylab = "Residuals")
plot(dat$asl_pred[as.numeric(names(gls2$residuals))], resid(gls2), xlab = "Bodysize", ylab = "Residuals")
plot(dat$hab.cat.b[as.numeric(names(gls2$residuals))], resid(gls2), xlab = "Habitat type", ylab = "Residuals")
plot(dat$hab_w_boot[as.numeric(names(gls2$residuals))], resid(gls2), xlab = "Habitat width", ylab = "Residuals")
par(op)
# Chunk 19: nested data
library(nlme) # linear mixed effects model
lme1 <- lme(data=dat.m, Form, random= ~1|order, method="REML")
anova(gls1, lme1)
# Chunk 21: linear_model
lm3 <- lm(data=dat, ma_range ~ mni_max + spec_max + grid_cells + gcd + lat_range +
mean_lat + min_lat + asl_pred + hab.cat.b + habitat_width + hab_w_boot + noo)
summary(lm3)
plot(all.effects(lm3))
layout(matrix(c(1,2,3,4),2,2)) # optional 4 graphs/page
plot(lm3)
layout(matrix(c(1,2,3,4),1,1)) # 1 graph/page
hist(residuals(lm3), breaks=40)
psych::describe(residuals(lm3),IQR=TRUE)
plot(all.effects(lm3))
# Chunk 22: linear_model_logged
lm3_log <- lm(data=dat, log(ma_range+1) ~ mni_max + grid_cells + gcd + lat_range +
mean_lat + min_lat + hab.cat.b + habitat_width + hab_w_boot + asl_pred + noo)
summary(lm3_log)
# Chunk 23: check_outliers_lm
dat.m <- na.omit(dat)
dat.m[as.numeric(names(which(abs(lm3$residuals)>10))),]
lm3_out <- lm(data=dat.m[-as.numeric(names(which(abs(lm3$residuals)>10))),],
ma_range ~ mni_max + grid_cells + gcd + lat_range +
mean_lat + min_lat + hab.cat.b + habitat_width + asl_pred)
summary(lm3_out)
hist(lm3_out$residuals, breaks=40)
# Chunk 24: log transforming_response
lm3_log <- lm(data=dat,
log(ma_range+1) ~ mni_max + grid_cells + gcd + lat_range +
mean_lat + min_lat + hab.cat.b + habitat_width + asl_pred)
summary(lm3_log)
layout(matrix(c(1,2,3,4),2,2)) # optional 4 graphs/page
plot(lm3_log)
layout(matrix(c(1,2,3,4),1,1))
hist(lm3_log$residuals, breaks=40)
# K-fold cross-validation
library(DAAG)
#cvk <-  cv.lm(data=dat.m, lm3_log, m=3) # 3 fold cross-validation
#10^attributes(cvk)$ms
# Chunk 25: generalized_model
# pseudo r^2
R2logit<- function(model){
R2<- 1-(model$deviance/model$null.deviance)
return(R2)
}
glm1 <- glm(data=dat, family="poisson",
ma_range ~ mni_max + grid_cells + gcd + lat_range + mean_lat + min_lat +
hab.cat.b + habitat_width + asl_pred)
hist(residuals(glm1), breaks=20)
summary(glm1)
library(pscl)
R2logit(glm1)
pR2(glm1)
# This second pseudo R looks way too good..
# removing min_lat to reduce colinearity:
glm2 <- glm(data=dat, family="poisson",
ma_range ~ mni_max + grid_cells + gcd + lat_range + mean_lat +
hab.cat.b + habitat_width + asl_pred)
hist(residuals(glm2), breaks=20)
summary(glm2)
R2logit(glm2)
# Chunk 26: glm.nb
library(MASS)
glmnb1 <- glm.nb(data=dat.m,
ma_range ~ mni_max + grid_cells + gcd + lat_range + mean_lat + min_lat +
hab.cat.b + habitat_width + asl_pred, init.theta = 0.3)
theta.md(dat$ma_range, fitted(glmnb1), dfr = df.residual(glmnb1))
summary(glmnb1)
1-(glmnb1$deviance/glmnb1$null.deviance) # this is % deviance explained
hist(residuals(glmnb1), breaks=20)
glmnb2 <- glm.nb(data=dat.m[dat.m$ma_range>0,],
ma_range ~ mni_max + grid_cells + gcd + lat_range + mean_lat + min_lat +
hab.cat.b + habitat_width + asl_pred, init.theta = 0.3)
summary(glmnb2)
1-(glmnb2$deviance/glmnb2$null.deviance)
hist(glmnb2$residuals)
cv.glmnb1 <- stepAIC(glmnb1, direction="both", use.start = TRUE)
cv.glmnb1$anova
cv.glmnb2 <- stepAIC(glmnb2, direction="both", use.start = TRUE)
cv.glmnb2$anova
# Chunk 27: mixed_model
library(lme4)
mix.all <- glmer(data=dat,
ma_range ~ mni_max + grid_cells + asl_pred + lat_range + mean_lat + hab.cat.b+(1|order),
family=negative.binomial(1.4)) # + min_lat including this makes error
summary(mix.all)
mix.all2 <- glmer.nb(data=dat,
ma_range ~ mni_max + grid_cells + asl_pred + lat_range + mean_lat +
factor(hab.cat.b)+(1|order))
summary(mix.all2)
# Chunk 29: GAM2
#library(gam)
library(mgcv)
gam.all <- gam(data=dat.m, ma_range ~ s(mni_max) + grid_cells + s(asl_pred) + s(lat_range) + s(mean_lat) + s(min_lat)+
hab.cat.b)
summary(gam.all)
hist(gam.all$residuals, breaks=40)
gam.negbin <- gam(data=dat.m, ma_range ~ s(mni_max) + grid_cells + s(asl_pred) + s(lat_range) + s(mean_lat) + s(min_lat)+
hab.cat.b, family=negbin(2)) #
summary(gam.negbin)
hist(gam.negbin$residuals, breaks=40)
# Chunk 30: zero_inflated_model
library(pscl)
f1 <- formula(as.integer(ma_range)~ mni_max + grid_cells + asl_pred + lat_range + mean_lat + min_lat) # + hab.cat.b
zi1 <- zeroinfl(f1, dist="negbin", link="logit", data=dat.m)
summary(zi1)
AIC(zi1)
hist(zi1$residuals, breaks=40)
# Chunk 31: gbm_model
library(gbm)
gbm.all <- gbm(data=dat, as.integer(ma_range)~ mni_max + grid_cells + gcd + asl_pred + lat_range + mean_lat + min_lat
+ factor(hab.cat.b),
n.trees=1000, distribution = "poisson")
summary(gbm.all, las=2)
hist(dat$ma_range-gbm.all$fit, breaks=40) # residuals
gbm.sub <- gbm(data=dat.m, as.integer(ma_range)~ mni_max + gcd + grid_cells + asl_pred + lat_range + mean_lat + min_lat
+ factor(hab.cat.b),
n.trees=1000, distribution = "poisson")
summary(gbm.sub, las=2)
hist(dat.m$ma_range-gbm.sub$fit, breaks=40) # residuals
gbm.no.geo <- gbm(data=dat, as.integer(ma_range)~ mni_max + asl_pred +
+ mean_lat + min_lat + factor(hab.cat.b),
n.trees=1000, distribution = "poisson")
summary(gbm.no.geo, las=2)
# comparing complete data versus incomplete data
all <- summary(gbm.all)
sub <- summary(gbm.sub)
comp <- merge(all, sub, by="var")
plot(comp[,2]~comp[,3], col="grey", ylab="incomplete data", xlab="complete data", pch=3)
#text(comp[,3], comp[,2], labels=comp$var)
# Plots the marginal effect of the selected variables by "integrating" out the other variables.
#plot.gbm(gbm.all, i.var=c(1)) #
#plot.gbm(gbm.all, i.var=c(4,5))
# Chunk 32: classfication_tree
# Clustering
#kmeans(dat.m$ma_range,3)
#fin$strat_clust <- as.factor($strat_clust)
library(tree)
tree1 <- tree(data=dat.m, ma_range~ mni_max + grid_cells + asl_pred + lat_range + mean_lat + min_lat
+ factor(hab.cat.b))
plot(tree1); text(tree1)
summary(tree1)
library(randomForest)
rf1 <- randomForest(data=dat.m, ma_range~ mni_max +  grid_cells + asl_pred +  mean_lat + hab.cat.b,
importance=TRUE, proximity=TRUE) #+lat_range ++ min_lat
rf1
plot(rf1)
# Chunk 33: reset settings
options(warn = oldw)
# Chunk 34: bayes
#library(brms)
#b1 <- brm(data=dat, ma_range ~ mni_max + grid_cells + asl_pred + lat_range + mean_lat + hab.cat.b+(1|order),
#            family=negbinomial())
#summary(b1)
